[["helper-functions.html", "2 Helper Functions 2.1 case_when() vs pd.cut() and np.select() 2.2 if_else() vs np.where() 2.3 %in% vs isin, @, and in 2.4 stringr::str_detect() vs str.contains() 2.5 distinct() vs unique() 2.6 slice() vs iloc()", " 2 Helper Functions 2.1 case_when() vs pd.cut() and np.select() Suppose we have a data frame with a variable called age. We want to create a variable age_cat with the following conditions: age &lt; 18: Kids 18 \\(\\leq\\) age &lt; 31: 18-30 31 \\(\\leq\\) age: 31 and above Example: age age_cat 9 Kids 10 Kids 18 18-30 21 18-30 29 18-30 31 31 and above 45 31 and above dplyr::case_when() With dplyr::case_when() we can do it in the following way: # example data df &lt;- tibble(age = c(9, 10, 18, 21, 29, 31, 45)) # case_when() in action df %&gt;% mutate(age_cat = case_when( age &lt; 18 ~ &quot;Kids&quot;, age &gt;= 18 &amp; age &lt; 31 ~ &quot;18-30&quot;, age &gt;= 31 ~ &quot;31 and above&quot; )) ## # A tibble: 7 x 2 ## age age_cat ## &lt;dbl&gt; &lt;chr&gt; ## 1 9 Kids ## 2 10 Kids ## 3 18 18-30 ## 4 21 18-30 ## 5 29 18-30 ## 6 31 31 and above ## 7 45 31 and above We can achieve the same result in Python using np.select() pd.cut() df = pd.DataFrame({&#39;age&#39;: [9, 10, 18, 21, 29, 31, 45]}) np.select() pd.cut() # Step 1: Create conditions cond = [ (df[&#39;age&#39;].lt(18)), (df[&#39;age&#39;].ge(18) &amp; (df[&#39;age&#39;].lt(31))), (df[&#39;age&#39;].ge(31)) ] # Step 2: Assign labels cond_labs = [ &#39;Kids&#39;, &#39;18-30&#39;, &#39;30 and above&#39; ] # Step 3: apply np.select() df[&#39;age_cat&#39;] = np.select(cond, cond_labs) df ## age age_cat ## 0 9 Kids ## 1 10 Kids ## 2 18 18-30 ## 3 21 18-30 ## 4 29 18-30 ## 5 31 30 and above ## 6 45 30 and above # Step 1: Create bin condition bin_cond = [0, 17, 30, np.inf] # note: instead of 0, # -np.inf will also work # # 0: greater than 0 # 17: upper limit is 17 # Step 2: Assign bin labs bin_labs = [ &#39;Kids&#39;, &#39;18-30&#39;, &#39;30 and above&#39; ] # Step 3: apply pd.cut() df[&quot;age_cat&quot;] = pd.cut( df[&quot;age&quot;], bins = bin_cond, labels = bin_labs ) df ## age age_cat ## 0 9 Kids ## 1 10 Kids ## 2 18 18-30 ## 3 21 18-30 ## 4 29 18-30 ## 5 31 30 and above ## 6 45 30 and above 2.2 if_else() vs np.where() Given prices of shirts price, how do we create a variable price_cat with the following conditions? when price is less than 50, we label it as Cheap when price is 50 or more, we label it as Expensive dplyr::if_else() np.where() # toy data prices &lt;- c(25, 30, 45, 80,100, 125) df &lt;- tibble(price = prices) # if_else in action df %&gt;% mutate(price_cat = if_else( price &lt;50, &quot;Cheap&quot;, &quot;Expenseive&quot; )) ## # A tibble: 6 x 2 ## price price_cat ## &lt;dbl&gt; &lt;chr&gt; ## 1 25 Cheap ## 2 30 Cheap ## 3 45 Cheap ## 4 80 Expenseive ## 5 100 Expenseive ## 6 125 Expenseive # toy data prices = { &#39;price&#39;: [25, 30, 45, 80,100, 125] } df = pd.DataFrame(prices) # np.where() in action df[&#39;price_cat&#39;] = np.where( df.price &lt; 50, &quot;Cheap&quot;, &quot;Expenseive&quot; ) df ## price price_cat ## 0 25 Cheap ## 1 30 Cheap ## 2 45 Cheap ## 3 80 Expenseive ## 4 100 Expenseive ## 5 125 Expenseive 2.3 %in% vs isin, @, and in code capital BD Dhaka PT Lisbon ES Madrid FR Paris How to keep observations that belong to BD or DE (without using the | operator)? R Python # toy data df &lt;- tibble( # country code code = c( &quot;BD&quot;, &quot;PT&quot;, &quot;ES&quot;, &quot;FR&quot; ), # capital capital = c( &quot;Dhaka&quot;, &quot;Lisbon&quot;, &quot;Madrid&quot;, &quot;Paris&quot; ) ) df ## # A tibble: 4 x 2 ## code capital ## &lt;chr&gt; &lt;chr&gt; ## 1 BD Dhaka ## 2 PT Lisbon ## 3 ES Madrid ## 4 FR Paris # %in% in action df %&gt;% filter(code %in% c(&quot;BD&quot;, &quot;PT&quot;)) ## # A tibble: 2 x 2 ## code capital ## &lt;chr&gt; &lt;chr&gt; ## 1 BD Dhaka ## 2 PT Lisbon # toy data data = { # country code &#39;code&#39;:[ &quot;BD&quot;, &quot;PT&quot;, &quot;ES&quot;, &quot;FR&quot; ], # capital &#39;capital&#39;:[ &quot;Dhaka&quot;, &quot;Lisbon&quot;, &quot;Madrid&quot;, &quot;Paris&quot; ] } df = pd.DataFrame(data) df ## code capital ## 0 BD Dhaka ## 1 PT Lisbon ## 2 ES Madrid ## 3 FR Paris isin # isin in action df[df[&quot;code&quot;].isin([&quot;BD&quot;, &quot;PT&quot;])] ## code capital ## 0 BD Dhaka ## 1 PT Lisbon @ country_list = [&quot;BD&quot;, &quot;PT&quot;] # @ in action df.query(&#39;code == @country_list&#39;) # note: you must create a list first # @[&quot;BD&quot;, &quot;PT&quot;] doesn&#39;t work # but, @list([&quot;BD&quot;, &quot;PT&quot;] works ## code capital ## 0 BD Dhaka ## 1 PT Lisbon in # in in action df.query(&#39;code in [&quot;BD&quot;, &quot;PT&quot;]&#39;) ## code capital ## 0 BD Dhaka ## 1 PT Lisbon 2.4 stringr::str_detect() vs str.contains() Example: info amount XYZ Deposit 2020 0 Cash Deposit 1 ATM 2 XYZ Fee 2021 3 XYZ Deposit 2021 4 How to keep or drop only those observations where info is about XYZ? R stringr::str_detect() Python str.contains() # toy data df &lt;- tibble( info = c( &quot;XYZ Deposit 2020&quot;, &quot;Cash Deposit&quot;, &quot;ATM&quot;, &quot;XYZ Fee 2021&quot;, &quot;XYZ Deposit 2021&quot; ), amount = seq(1,5) - 1 ) df ## # A tibble: 5 x 2 ## info amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 XYZ Deposit 2020 0 ## 2 Cash Deposit 1 ## 3 ATM 2 ## 4 XYZ Fee 2021 3 ## 5 XYZ Deposit 2021 4 Keep: # str_detect() in action df %&gt;% filter( # keeps stringr::str_detect( info, &quot;XYZ&quot; ) ) ## # A tibble: 3 x 2 ## info amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 XYZ Deposit 2020 0 ## 2 XYZ Fee 2021 3 ## 3 XYZ Deposit 2021 4 Drop: # str_detect() in action df %&gt;% filter( # drops ! stringr::str_detect( info, &quot;XYZ&quot; ) ) ## # A tibble: 2 x 2 ## info amount ## &lt;chr&gt; &lt;dbl&gt; ## 1 Cash Deposit 1 ## 2 ATM 2 # toy data df = pd.DataFrame({ &#39;info&#39;: [ &quot;XYZ Deposit 2020&quot;, &quot;Cash Deposit&quot;, &quot;ATM&quot;, &quot;XYZ Fee 2021&quot;, &quot;XYZ Deposit 2021&quot; ], &#39;amount&#39;: np.arange(5) }) df ## info amount ## 0 XYZ Deposit 2020 0 ## 1 Cash Deposit 1 ## 2 ATM 2 ## 3 XYZ Fee 2021 3 ## 4 XYZ Deposit 2021 4 Keep: # str.contains in action: keep df[df[&#39;info&#39;].str.contains(&quot;XYZ&quot;)] ## info amount ## 0 XYZ Deposit 2020 0 ## 3 XYZ Fee 2021 3 ## 4 XYZ Deposit 2021 4 Drop: # str.contains in action: drop df[~ df[&#39;info&#39;].str.contains(&quot;XYZ&quot;)] ## info amount ## 1 Cash Deposit 1 ## 2 ATM 2 2.5 distinct() vs unique() name year A 2020 B 2020 C 2020 A 2021 B 2021 D 2021 What are the distinct names? dplyr::distinct() pd.unique() # toy data df &lt;- tibble( name = c( &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;D&#39; ), year = c( 2020, 2020, 2020, 2021, 2021, 2021 ) ) # dplyr::distinct in action df %&gt;% distinct(name) ## # A tibble: 4 x 1 ## name ## &lt;chr&gt; ## 1 A ## 2 B ## 3 C ## 4 D # if you want to count df %&gt;% distinct(name) %&gt;% count() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 4 # toy data df = pd.DataFrame({ &#39;name&#39;:[ &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;D&#39; ], &#39;year&#39;:[ 2020, 2020, 2020, 2021, 2021, 2021 ] }) # pd.unique() in action df[&#39;name&#39;].unique() ## array([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;], dtype=object) # if you want to count len(df[&#39;name&#39;].unique()) ## 4 2.6 slice() vs iloc() age id 20 1 21 1 22 1 23 1 24 1 How to slice single or multiple rows? dplyr::slice() pd.iloc() # toy data df &lt;- tibble( age = seq(20,24), id = seq(1,5) ) df ## # A tibble: 5 x 2 ## age id ## &lt;int&gt; &lt;int&gt; ## 1 20 1 ## 2 21 2 ## 3 22 3 ## 4 23 4 ## 5 24 5 # slice row 1 df %&gt;% slice(1) ## # A tibble: 1 x 2 ## age id ## &lt;int&gt; &lt;int&gt; ## 1 20 1 # slice rows 3 and 4 df %&gt;% slice(3:4) ## # A tibble: 2 x 2 ## age id ## &lt;int&gt; &lt;int&gt; ## 1 22 3 ## 2 23 4 # toy data df = pd.DataFrame({ &#39;age&#39; : np.arange(20, 25), &#39;id&#39;: np.arange(1, 6) }) df ## age id ## 0 20 1 ## 1 21 2 ## 2 22 3 ## 3 23 4 ## 4 24 5 # slice row 1 df.iloc[0:1] ## age id ## 0 20 1 # slice row 3 and 4 df.iloc[2:4] ## age id ## 2 22 3 ## 3 23 4 "]]
