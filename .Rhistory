print(i)
quit
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(smaller_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(smaller_than_100, toy_list)]
type(mapped_list)
print(mapped_list)
quit
reticulate::repl_python()
# Use map() with lambda function
[*map(lambda x: x < 100, toy_list)]
quit
reticulate::repl_python()
*map(lambda x: x < 100, toy_list)
quit
reticulate::repl_python()
x = [1, 3, 7, 9]
y = [1, 9, 49, 81]
[*zip(x, y)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [1, 6, 42, 72]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [1, 5, 8, 9]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [1, 5, 8, 18]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [10, 11, 12, 13]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# zip() will continue upto the length of the shortest input
short_list = [1, 2]
long_list = [16, 7, 8, 9]
[*zip(short_list, long_list)]
quit
library(reticulate)
py_install("itertools")
reticulate::repl_python()
from itertools import zip_longest
quit
reticulate::repl_python()
from itertools import zip_longest
[*zip_longest(short_list, long_list, fillvalues = None)]
quit
reticulate::repl_python()
from itertools import zip_longest
[*zip_longest(short_list, long_list, fillvalues = None)]
quit
reticulate::repl_python()
from itertools import zip_longest
[*zip_longest(short_list, long_list, fillvalue = None)]
3000/12
250+1080
quit
reticulate::repl_python()
toy_names = ["Robin", "Barney", "Ted", "Lilly", "Marshall"]
enumerate(toy_names)
list(enumerate(toy_names))
quit
reticulate::repl_python()
toy_names = ["Robin", "Barney", "Ted", "Lilly", "Marshall"]
enumerate(toy_names)
quit
reticulate::repl_python()
# Use enumerate() in a for loop
for i, j in enumerate(toy_names):
print(i, j)
quit
# Use enumerate() in a for loop
for i, j in enumerate(toy_names):
print(i, j)
quit
dup_names = ["Robin", "Barney","Robin", "Ted", "Lilly", "Marshall", "Robin", "Ted", "Barney"]
names_dic = {dup_names:[] for name in set(dup_names)}
print(names_dic)
quit
reticulate::repl_python()
dup_names_list = ["Robin", "Barney","Robin", "Ted", "Lilly", "Marshall", "Robin", "Ted", "Barney"]
# create dictionary, keys:names; values: empty
names_dic = {name:[] for name in set(dup_names_list)}
print(names_dic)
# use enumerate() to store the index for each occurence
for index, name in enumerate(dup_names_list):
names_dic[name].append(index)
print(names_dic)
quit
reticulate::repl_python()
dup_names_list = ["Robin", "Barney","Robin", "Ted", "Lilly", "Marshall", "Robin", "Ted", "Barney"]
# create dictionary, keys:names; values: empty
names_dic = {name:[] for name in set(dup_names_list)}
print(names_dic)
quit
reticulate::repl_python()
# use enumerate() to store the index for each occurence
reticulate::repl_python()
for index, name in enumerate(dup_names_list):
names_dic[name].append(index)
print(names_dic)
quit
reticulate::repl_python()
# use enumerate() to store the index for each occurence
for index, name in enumerate(dup_names_list):
names_dic[name].append(index)
print(names_dic)
reticulate::repl_python()
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
quit
reticulate::repl_python()
import sklearn
sklearn.__version__ # checks version
quit
reticulate::repl_python()
from sklearn import linear_model
from sklearn.metrics import mean_squared_error, r2_score
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
df.shape()
df.head()
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
olympic.shape()
olympic.head()
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
olympic.shape
olympic.head()
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
olympic.head()
olympic.tail()
quit
reticulate::repl_python()
import sklearn
# check version
sklearn.__version__
quit
reticulate::repl_python()
olympic.tail()
quit
reticulate::repl_python()
plt.scatter('year', 'time', data = olympic)
quit
reticulate::repl_python()
plt.scatter('year', 'time', data = olympic)
quit
reticulate::repl_python()
plt.scatter('year', 'time', data = olympic)
plt.show()
quit
reticulate::repl_python()
# create an instance of a linear regression model where we will estimate the intercept
model = linear_model.LinearRegression(fit_intercept = True)
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
x
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
type(x)
quit
reticulate::repl_python()
X = x.reshape([-1, 1]) # here - 1 means "I don't know how many..."
quit
reticulate::repl_python()
# if you know the dimensions
X = x.reshape((28, 1))
quit
reticulate::repl_python()
# if you know the dimensions
X = x.reshape((28, 1))
quit
reticulate::repl_python()
# Now check the shape
print(X.shape)
quit
reticulate::repl_python()
olympic.time
quit
reticulate::repl_python()
type(olympic.time)
quit
reticulate::repl_python()
olympic.time.shape()
quit
reticulate::repl_python()
olympic.time.shape
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
x.shape
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
x.shape
type(x)
quit
reticulate::repl_python()
y = olympic.time
quit
reticulate::repl_python()
y = olympic.time
y.shape
type(y)
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
print(model.coef_) # coefficient
print(model.intercept_) # intercept
quit
reticulate::repl_python()
prediction_x = np.linspace(1900, 2000, 101)
prediction_x
quit
reticulate::repl_python()
# New X as np array
prediction_x = np.linspace(1900, 2000, 101)
# reshape it
prediction_x = predictin_x.reshape([-1, 1]) # recall -1 stands for "i don't know"
# Predict
model.predict(prediction_x)
quit
reticulate::repl_python()
# New X as np array
prediction_x = np.linspace(1900, 2000, 101)
# reshape it
prediction_x = predictin_x.reshape([-1, 1]) # recall -1 stands for "i don't know"
quit
reticulate::repl_python()
# New X as np array
prediction_x = np.linspace(1900, 2000, 101)
# reshape it
prediction_x = prediction_x.reshape([-1, 1]) # recall -1 stands for "i don't know"
quit
reticulate::repl_python()
mode.predict(prediction_x)
quit
reticulate::repl_python()
model.predict(prediction_x)
quit
reticulate::repl_python()
model.predict(prediction_x)
quit
reticulate::repl_python()
plt.scatter(x, y)
quit
reticulate::repl_python()
plt.scatter(x, y)
plt.plot(prediction_x, model.predict(prediction_x), color = 'red')
quit
plt.scatter(x, y)
reticulate::repl_python()
plt.plot(prediction_x, model.predict(prediction_x), color = 'red')
quit
reticulate::repl_python()
plt.scatter(x, y)
plt.plot(prediction_x, model.predict(prediction_x), color = 'red')
plt.show()
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals) # check mean
# plot
plt.hist(residuals)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals) # check mean
# plot
plt.hist(residuals)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals) # check mean
# plot
residuals.plt.hist()
quit
reticulate::repl_python()
plt.hist(residuals)
quit
reticulate::repl_python()
plt.hist(residuals)
quit
library(reticulate)
install_miniconda()
reticulate::repl_python()
plt.hist(residuals)
plt.show()
quit
reticulate::repl_python()
plt.plot(x, residuals, "o")
quit
plt.plot(x, residuals, "o")
reticulate::repl_python()
plt.plot(x, residuals, "o")
olympics.dtypes
quit
reticulate::repl_python()
olympic.dtypes
quit
reticulate::repl_python()
olympic
quit
reticulate::repl_python()
type(olympic)
quit
reticulate::repl_python()
type(olympic[['year']])
quit
reticulate::repl_python()
olympic[['year']].shape
quit
reticulate::repl_python()
X2 = olympic[['year']]
X2.shape
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
print(model.coef_) # coefficient
print(model.intercept_) # intercept
quit
reticulate::repl_python()
# Now fit the model
model.fit(X2, y)
print(model.coef_) # coefficient
print(model.intercept_) # intercept
reticulate::repl_python()
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.datasets import load_iris
from sklearn import linear_model, preprocessing, model_selection
from sklearn.model_selection import train_test_split, cross_val_score
quit
reticulate::repl_python()
# x is our predictor matrix
# y is a numeric output - for regression methods
# z is a categorical output - for classification methods
X = np.arange(20).reshape((2, -1)).T
y = np.arange(10)
z = np.array([0,0,0,0,0,1,1,1,1,1])
print(X)
print(y)
print(z)
quit
library(reticulate)
reticulate::repl_python()
train_test_split(X, test_size = 1/4, random_state = 1)
quit
reticulate::repl_python()
# Example data: ironslag
iron = pd.read_csv('https://raw.githubusercontent.com/bhaswar-chakma/toolbox/main/data/ironslag.csv')
iron.head()
quit
reticulate::repl_python()
iron.head()
iron.shape
quit
reticulate::repl_python()
plt.scatter(iron.magnetic, iron.chemical)
quit
reticulate::repl_python()
X_train, X_test, y_train, y_test = train_test_split(
iron, test_size = 1/5, random_state = 1
)
quit
reticulate::repl_python()
train, test = train_test_split(
iron, test_size = 1/5, random_state = 1
)
quit
reticulate::repl_python()
train
quit
reticulate::repl_python()
test
quit
reticulate::repl_python()
plt.scatter(train.magnetic, train.chemical)
quit
reticulate::repl_python()
plt.scatter(train.magnetic, train.chemical)
quit
reticulate::repl_python()
plt.scatter(train.magnetic, train.chemical)
quit
plt.scatter(train.magnetic, train.chemical)
reticulate::repl_python()
plt.scatter(train.magnetic, train.chemical)
quit
reticulate::repl_python()
train.magnetic.values
quit
reticulate::repl_python()
# sklearn requires our predictor variables to be in a two dimensional array
# reshape to have 1 column
# the -1 in reshape means I don't want to figure out all the necessary dimensions
# i want 1 column, and numpy, you figure out how many rows I need
X = train.magnetic.values.reshape(-1,1)
X.shape
quit
reticulate::repl_python()
y = train.chemical.values
y.shape
quit
reticulate::repl_python()
np.corrcoef(train.magnetic.values, train.chemical.values)
quit
reticulate::repl_python()
# r-squared
np.corrcoef(train.magnetic.values, train.chemical.values)[0,1] ** 2
quit
0.70876994^2
reticulate::repl_python()
linear = linear_model.LinearRegression()
linear.fit(X, y)
quit
reticulate::repl_python()
# linear.score is the R^2 value
# how much error is reduced from no model (variance or MSE)
# vs having the regression model
linear.score(X, y)
quit
reticulate::repl_python()
# linear.score is the R^2 value
# how much error is reduced from no model (variance or MSE)
# vs having the regression model
linear.score(X, y)
np.arange(10, 40)
quit
reticulate::repl_python()
x_predict = np.arange(10, 40).reshape(-1,1)
quit
reticulate::repl_python()
plt.scatter(X, y)
plt.plot(x_predict, lin_y_hat, c = 'red')
quit
reticulate::repl_python()
# shuffle split says 'shuffle the data' and split it into 5 equal parts
cv = model_selection.ShuffleSplit(n_splits = 5, test_size = 0.3, random_state=0)
cv_linear = model_selection.cross_val_score(linear, X, y, cv = cv)
print(cv_linear)
print(np.mean(cv_linear))
