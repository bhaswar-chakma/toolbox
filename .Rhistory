# test the function
smaller_than_100(2)
quit
reticulate::repl_python()
# toy list
toy_list = [1, 200, 3, 400]
# Create toy function
def smaller_than_100(k):
if k < 100:
return True
else:
False
# test the function
smaller_than_100(2)
quit
reticulate::repl_python()
# toy list
toy_list = [1, 200, 3, 400]
# Create toy function
def smaller_than_100(k):
if k < 100:
return True
else:
False
# test the function
smaller_than_100(2)
quit
reticulate::repl_python()
# apply it to toy_list
map(smaller_than_100, toy_list)
quit
reticulate::repl_python()
# apply it to toy_list
mapped = map(smaller_than_100, toy_list)
print(mapped)
quit
reticulate::repl_python()
# apply it to toy_list
mapped = map(smaller_than_100, toy_list)
print(mapped)
quit
reticulate::repl_python()
# apply it to toy_list
mapped = map(smaller_than_100, toy_list)
print(mapped)
quit
reticulate::repl_python()
# apply it to toy_list
mapped = map(smaller_than_100, toy_list)
print(mapped)
quit
reticulate::repl_python()
for i in mapped():
print(i)
quit
for i in mapped:
print(i)
quit
for i in mapped:
print(i)
quit
# apply it to toy_list
mapped = map(smaller_than_100, toy_list)
print(mapped) # doesn't provide the desired output; use loop
quit
for i in mapped:
reticulate::repl_python()
print(i)
quit
reticulate::repl_python()
for k in mapped:
print(k)
quit
for k in mapped:
print(k)
quit
for k in mapped:
print(k)
quit
for k in mapped:
print(k)
quit
for k in mapped:
print(k)
quit
for i in mapped:
print(i)
quit
for i in mapped:
print(i)
quit
for i in mapped:
print(i)
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
quit
reticulate::repl_python()
# toy list
toy_list = [1, 200, 3, 400]
# Create toy function
def smaller_than_100(k):
if k < 100:
return True
else:
False
# test the function
smaller_than_100(2)
# apply it to toy_list
mapped = map(smaller_than_100, toy_list)
print(mapped) # doesn't provide the desired output; use loop
for i in mapped:
print(i)
quit
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(less_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(smaller_than_100, toy_list)]
mapped_list
quit
reticulate::repl_python()
# Extract mapping into new list
mapped_list = [*map(smaller_than_100, toy_list)]
type(mapped_list)
print(mapped_list)
quit
reticulate::repl_python()
# Use map() with lambda function
[*map(lambda x: x < 100, toy_list)]
quit
reticulate::repl_python()
*map(lambda x: x < 100, toy_list)
quit
reticulate::repl_python()
x = [1, 3, 7, 9]
y = [1, 9, 49, 81]
[*zip(x, y)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [1, 6, 42, 72]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [1, 5, 8, 9]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [1, 5, 8, 18]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# can operate on more than two inputs
z = [10, 11, 12, 13]
[*zip(x, y, z)]
quit
reticulate::repl_python()
# zip() will continue upto the length of the shortest input
short_list = [1, 2]
long_list = [16, 7, 8, 9]
[*zip(short_list, long_list)]
quit
library(reticulate)
py_install("itertools")
reticulate::repl_python()
from itertools import zip_longest
quit
reticulate::repl_python()
from itertools import zip_longest
[*zip_longest(short_list, long_list, fillvalues = None)]
quit
reticulate::repl_python()
from itertools import zip_longest
[*zip_longest(short_list, long_list, fillvalues = None)]
quit
reticulate::repl_python()
from itertools import zip_longest
[*zip_longest(short_list, long_list, fillvalue = None)]
3000/12
250+1080
quit
reticulate::repl_python()
toy_names = ["Robin", "Barney", "Ted", "Lilly", "Marshall"]
enumerate(toy_names)
list(enumerate(toy_names))
quit
reticulate::repl_python()
toy_names = ["Robin", "Barney", "Ted", "Lilly", "Marshall"]
enumerate(toy_names)
quit
reticulate::repl_python()
# Use enumerate() in a for loop
for i, j in enumerate(toy_names):
print(i, j)
quit
# Use enumerate() in a for loop
for i, j in enumerate(toy_names):
print(i, j)
quit
dup_names = ["Robin", "Barney","Robin", "Ted", "Lilly", "Marshall", "Robin", "Ted", "Barney"]
names_dic = {dup_names:[] for name in set(dup_names)}
print(names_dic)
quit
reticulate::repl_python()
dup_names_list = ["Robin", "Barney","Robin", "Ted", "Lilly", "Marshall", "Robin", "Ted", "Barney"]
# create dictionary, keys:names; values: empty
names_dic = {name:[] for name in set(dup_names_list)}
print(names_dic)
# use enumerate() to store the index for each occurence
for index, name in enumerate(dup_names_list):
names_dic[name].append(index)
print(names_dic)
quit
reticulate::repl_python()
dup_names_list = ["Robin", "Barney","Robin", "Ted", "Lilly", "Marshall", "Robin", "Ted", "Barney"]
# create dictionary, keys:names; values: empty
names_dic = {name:[] for name in set(dup_names_list)}
print(names_dic)
quit
reticulate::repl_python()
# use enumerate() to store the index for each occurence
reticulate::repl_python()
for index, name in enumerate(dup_names_list):
names_dic[name].append(index)
print(names_dic)
quit
reticulate::repl_python()
# use enumerate() to store the index for each occurence
for index, name in enumerate(dup_names_list):
names_dic[name].append(index)
print(names_dic)
reticulate::repl_python()
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
quit
reticulate::repl_python()
import sklearn
sklearn.__version__ # checks version
quit
reticulate::repl_python()
from sklearn import linear_model
from sklearn.metrics import mean_squared_error, r2_score
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
df.shape()
df.head()
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
olympic.shape()
olympic.head()
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
olympic.shape
olympic.head()
quit
reticulate::repl_python()
# data
olympic = pd.read_csv("https://raw.githubusercontent.com/sdrogers/fcmlcode/master/R/data/olympics/male100.csv", names = ["year","time"])
olympic.head()
olympic.tail()
quit
reticulate::repl_python()
import sklearn
# check version
sklearn.__version__
quit
reticulate::repl_python()
olympic.tail()
quit
reticulate::repl_python()
plt.scatter('year', 'time', data = olympic)
quit
reticulate::repl_python()
plt.scatter('year', 'time', data = olympic)
quit
reticulate::repl_python()
plt.scatter('year', 'time', data = olympic)
plt.show()
quit
reticulate::repl_python()
# create an instance of a linear regression model where we will estimate the intercept
model = linear_model.LinearRegression(fit_intercept = True)
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
x
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
type(x)
quit
reticulate::repl_python()
X = x.reshape([-1, 1]) # here - 1 means "I don't know how many..."
quit
reticulate::repl_python()
# if you know the dimensions
X = x.reshape((28, 1))
quit
reticulate::repl_python()
# if you know the dimensions
X = x.reshape((28, 1))
quit
reticulate::repl_python()
# Now check the shape
print(X.shape)
quit
reticulate::repl_python()
olympic.time
quit
reticulate::repl_python()
type(olympic.time)
quit
reticulate::repl_python()
olympic.time.shape()
quit
reticulate::repl_python()
olympic.time.shape
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
x.shape
quit
reticulate::repl_python()
# Create an X matrix using the x values
x = olympic.year.values
x.shape
type(x)
quit
reticulate::repl_python()
y = olympic.time
quit
reticulate::repl_python()
y = olympic.time
y.shape
type(y)
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
print(model.coef_) # coefficient
print(model.intercept_) # intercept
quit
reticulate::repl_python()
prediction_x = np.linspace(1900, 2000, 101)
prediction_x
quit
reticulate::repl_python()
# New X as np array
prediction_x = np.linspace(1900, 2000, 101)
# reshape it
prediction_x = predictin_x.reshape([-1, 1]) # recall -1 stands for "i don't know"
# Predict
model.predict(prediction_x)
quit
reticulate::repl_python()
# New X as np array
prediction_x = np.linspace(1900, 2000, 101)
# reshape it
prediction_x = predictin_x.reshape([-1, 1]) # recall -1 stands for "i don't know"
quit
reticulate::repl_python()
# New X as np array
prediction_x = np.linspace(1900, 2000, 101)
# reshape it
prediction_x = prediction_x.reshape([-1, 1]) # recall -1 stands for "i don't know"
quit
reticulate::repl_python()
mode.predict(prediction_x)
quit
reticulate::repl_python()
model.predict(prediction_x)
quit
reticulate::repl_python()
model.predict(prediction_x)
quit
reticulate::repl_python()
plt.scatter(x, y)
quit
reticulate::repl_python()
plt.scatter(x, y)
plt.plot(prediction_x, model.predict(prediction_x), color = 'red')
quit
plt.scatter(x, y)
reticulate::repl_python()
plt.plot(prediction_x, model.predict(prediction_x), color = 'red')
quit
reticulate::repl_python()
plt.scatter(x, y)
plt.plot(prediction_x, model.predict(prediction_x), color = 'red')
plt.show()
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals) # check mean
# plot
plt.hist(residuals)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals) # check mean
# plot
plt.hist(residuals)
quit
reticulate::repl_python()
# find residuals
residuals = y - model.predict(X)
np.mean(residuals) # check mean
# plot
residuals.plt.hist()
quit
reticulate::repl_python()
plt.hist(residuals)
quit
reticulate::repl_python()
plt.hist(residuals)
quit
library(reticulate)
install_miniconda()
reticulate::repl_python()
plt.hist(residuals)
plt.show()
quit
reticulate::repl_python()
plt.plot(x, residuals, "o")
quit
plt.plot(x, residuals, "o")
reticulate::repl_python()
plt.plot(x, residuals, "o")
olympics.dtypes
quit
reticulate::repl_python()
olympic.dtypes
quit
reticulate::repl_python()
olympic
quit
reticulate::repl_python()
type(olympic)
quit
reticulate::repl_python()
type(olympic[['year']])
quit
reticulate::repl_python()
olympic[['year']].shape
quit
reticulate::repl_python()
X2 = olympic[['year']]
X2.shape
quit
reticulate::repl_python()
# Now fit the model
model.fit(X, y)
print(model.coef_) # coefficient
print(model.intercept_) # intercept
quit
reticulate::repl_python()
# Now fit the model
model.fit(X2, y)
print(model.coef_) # coefficient
print(model.intercept_) # intercept
